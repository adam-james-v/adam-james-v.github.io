<!DOCTYPE html>
<html><head><meta charset="utf-8"><title>Stream Art</title><link href="style.css" rel="stylesheet" type="text/css"><link href="codemirror.css" rel="stylesheet" type="text/css"><link href="nord.css" rel="stylesheet" type="text/css"><script src="codemirror.js" type="text/javascript"></script><script src="clojure.js" type="text/javascript"></script><script src="react.production.min.js" type="text/javascript"></script><script src="react-dom.production.min.js" type="text/javascript"></script><script src="radish.js" type="text/javascript"></script><script src="radish.reagent.js" type="text/javascript"></script><script type="application/x-scittle">(require '[reagent.core :as r]
         '[reagent.dom :as rdom])

(defn editor
  [id ns-str state]
  (let [cm (.fromTextArea  js/CodeMirror
                           (.getElementById js/document id)
                           #js {:mode "clojure"
                                :theme "nord"
                                :lineNumbers true
                                :smartIndent true
                                :tabSize 2})]
    (.on cm "change" (fn [_ _]
                       (reset! state (str ns-str (.getValue cm)))))
    (.setSize cm "auto" "auto")))

(defn renderable-element?
  [elem]
  (and (vector? elem)
       (keyword? (first elem))
       (not= (str (first elem)) ":")
       (not (str/includes? (str (first elem)) "/"))
       (not (re-matches #"[0-9.#].*" (name (first elem))))
       (re-matches #"[a-zA-Z0-9.#]+" (name (first elem)))))

(defn renderable?
  [elem]
  (when (or (renderable-element? elem) (seq? elem))
    (let [[k props content] elem
          [props content] (if (and (nil? content)
                                   (not (map? props)))
                            [nil props]
                            [props content])]
      (cond
        (seq? elem) (not (empty? (filter renderable? elem)))
        (seq? content) (not (empty? (filter renderable? content)))
        :else (or (renderable-element? content)
                  (renderable-element? elem)
                  (string? content)
                  (number? content))))))

(defn result-component
  [ns-str state]
  (fn [ns-str state]
    (let [result (try (js/radish.core.eval_string (str ns-str @state))
                      (catch :default e
                        (.-message e)))]
      [:div.result
       [:pre
        [:div "RESULT:"]
        (when (renderable? result) [:div.render result])
        [:code (if result (str result) "nil")]]])))

(def current-ns (atom `'~'user))

(defn contains-ns?
  [s]
  (str/includes? s "(ns "))

(defn extract-ns
  [src-str]
  (->> src-str
       (#(str "[" % "]"))
       read-string
       (filter (fn [[sym & _]] (= sym 'ns))) ;; drop any code that isn't a ns decl
       last
       second))

(defn run-src
  [elem]
  (let [id (gensym "src-")
        src-str (.-innerText elem)
        parent (.-parentNode elem)
        this-ns (if (contains-ns? src-str)
                  `'~(extract-ns src-str)
                  @current-ns)
        ns-str (str "(in-ns " this-ns ")\n")
        state (r/atom src-str)]
    (reset! current-ns this-ns) 
    (rdom/render [:textarea {:id id} src-str] parent)
    (editor id ns-str state)
    (rdom/render [result-component ns-str state] parent)))

(defn run! []
  (let [blocks (vec (.getElementsByClassName js/document "src-clojure"))]
    (mapv run-src blocks)))

(run!)
</script></head><body><header><h1>Stream Art</h1></header><main><section id="root"><section class="hsec2"><h2>stream-art</h2><p>Using svg-clj to create some stream art assets and/or make generative art while streaming.
<p></p></p></section><section class="hsec2"><h2>deps</h2><div class="code-container"><pre class="src-clojure-ref">{:deps
  {io.github.adam-james-v/svg-clj {:mvn/version "0.0.3-SNAPSHOT"}
   hiccup/hiccup                  {:mvn/version "2.0.0-alpha2"}}}
</pre></div><p></p></section><section class="hsec2"><h2>ns</h2><div class="code-container"><pre class="src-clojure">(ns stream-art.draw
 (:require  [svg-clj.utils :as utils]
  [svg-clj.elements :as el]
  [svg-clj.transforms :as tf]
  [svg-clj.composites :as comp :refer [svg]]
  [svg-clj.path :as path]
  [svg-clj.parametric :as p]
  [svg-clj.layout :as lo]))</pre></div><p></p></section><section class="hsec2"><h2>utils</h2><section class="hsec3"><h3>svg</h3>Make an SVG function. It turns out that you can natively display SVG in emacs (GUI mode, not terminal). This lets us export SVG to a file and immediately display it as a code block result. The svg! fn helps with this.
<p>This is a side-effecting function that writes a file to the same directory as this org file. If you want to control where images are saved, you can change this function and/or the fn calls to save into a directory structure of your choosing.
<p>The file name is returned as a symbol so that org-mode correctly inserts an inline image link to that filename. If you return it as a string, org-mode incorrectly has double quotes around the filename, resulting in no display of the image.
<p><div class="code-container"><pre class="src-clojure">#_(defn svg!
  [svg-data fname]
  (let [svg-data (if (= (first svg-data) :svg)
                   svg-data
                   (svg svg-data))]
    (spit fname (html svg-data))
    (symbol fname)))
</pre></div><p></p></p></p></p></section></section><section class="hsec2"><h2>drawing</h2>This is where I build the drawing...
<p></p><section class="hsec3"><h3>Ideation</h3>Start the drawing process with a very simple random pattern that looks quite nice. Randomly draw forward or backward slashes along a square grid to make a maze type pattern. Very simple, but still quite pleasing.
<p>Here are some parameters for the drawing.
<p><div class="code-container"><pre class="src-clojure">(def cell-size 20)
(def base-style {:stroke "#ff839d"
                 :stroke-width 3
                 :stroke-linecap "round"})</pre></div><p>And here we can quickly assemble an example.
<p><div class="code-container"><pre class="src-clojure">(def fsl
  (-> (el/line [cell-size 0] [0 cell-size])
      (tf/style base-style)))

(def bsl
  (-> (el/line [0 0] [cell-size cell-size])
      (tf/style base-style)))

(defn rsl []
  (let [idx (rand-int 2)]
    (get [fsl bsl] idx)))

(->
  (lo/distribute-on-pts 
   (repeatedly rsl) 
   (p/rect-grid 20 20 cell-size cell-size))
  svg)</pre></div><p>I think we can extend this premise using some simple bezier curves to add to the list of curves to draw within each cell.
<p><div class="code-container"><pre class="src-clojure">(def cell-size 16)
(def base-style {:stroke "#ff839d"
                 :fill "none"
                 :stroke-width 3
                 :stroke-linecap "round"})

(def fsl
  (-> (path/line [cell-size 0]
                   [0 cell-size])
      (tf/style base-style)))

(def bsl
  (-> (path/line [0 0]
                   [cell-size cell-size])
      (tf/style base-style)))

(def bfsl1
  (-> (path/bezier [cell-size 0]
                   [0 0]
                   [0 cell-size])
      (tf/style base-style)))

(def bbsl1
  (-> (path/bezier [0 0] 
                   [0 cell-size]
                   [cell-size cell-size])
      (tf/style base-style)))

(def bfsl2
  (-> (path/bezier [cell-size 0]
                   [0 0]
                   [cell-size cell-size]
                   [0 cell-size])
      (tf/style base-style)))

(def bbsl2
  (-> (path/bezier [0 0] 
                   [0 cell-size] 
                   [cell-size 0]
                   [cell-size cell-size])
      (tf/style base-style)))

(defn rsl []
  (let [idx (rand-int 6)]
    (get [fsl bsl bfsl1 bbsl1 bfsl2 bbsl2] idx)))

(->
  (lo/distribute-on-pts 
   (repeatedly rsl) 
   (p/rect-grid 20 20 cell-size cell-size))
  svg)
</pre></div><p>If I use circle paths, I can make a neat looking ring of glyphs.
<p><div class="code-container"><pre class="src-clojure">(defn circle-pts [n r]
  (let [step (/ 1 n)]
    (map (p/circle r) (range 0 1 step))))
  
(->
  (lo/distribute-on-pts 
   (repeatedly 200 rsl) 
   (concat
    (circle-pts 28 120)
    (circle-pts 28 120)))
  svg)</pre></div><p>A new idea... deviate a pt randomly within a radius around itself, or do not deviate according to some deviation chance distribution.
<p>It would be cooler to have a 'deviate along' function where a point deviates some distance within R only along a single vector. This could be used to make a circle with random 'rays' extending from its center. It would look cooler I think.
<p><div class="code-container"><pre class="src-clojure">(def deviate-chance [true true true false false])

(defn- rand-t [] 
  (let [n 10] 
    (/ (inc (rand-int n)) (float n))))

(defn deviate [c ctr pt]
  (let [deviate?
        (get deviate-chance (rand-int (count deviate-chance)))]
    (if deviate?
      (let [ray (p/line ctr pt)]
        (ray ((get [- +] (rand-int 2)) 1 (* (rand-t) c))))
      pt)))
      
(defn devious-poly
  [n r]
  (let [pts (mapv (partial deviate 0.125 [0 0]) (circle-pts n r))]
    (path/polygon pts)))

(-> 
  (el/g 
   (devious-poly 60 120) 
   (devious-poly 50 100) 
   (devious-poly 40 80) 
   (devious-poly 30 60) 
   (devious-poly 20 40) 
   (devious-poly 10 20))
  (tf/style base-style)
  svg)
</pre></div><p></p></p></p></p></p></p></p></p></p></p></p></p></section></section><section class="hsec2"><h2>This is a work in progress example</h2>This project is ongoing, but I think is still worth pushing to my blog as an example of how you can 'evolve' your documents.
<p>For something non-critical like this artwork, it's a fun, low-concern way to iterate on some simple ideas. It's actually a lot of fun to play with ideas directly in the webpage output too, though at this time, you still can't save changes in the browser, so just be sure to copy/paste any winning ideas back into your orginal document.
<p>Over time, I think I will make things more ergonomic for this use case, but I am very pleased with how fun and simple it was to mess around with creating some artwork using Clojurescript and SVG in the browser.
<p>Feel free to mess around with the code I've got above. Have a nice day, stay cool, stay healthy.
</p></p></p></section></section></main><footer><p>Written by <span style="font-style:italic;">Adam James</span></p><p>Generated by <span style="font-weight:bold;"><a href="https://github.com/adam-james-v/radish">radish</a></span></p></footer></body></html>
