{"version":3,"sources":["same/ish.cljc"],"mappings":"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","names":["same.ish/default-comparator","same.compare/compare-ulp","same.ish/*comparator*","same.ish/split-floats","coll","cljs.core.reduce","p__36872","vec__36873","cljs.core.nth","floats","rest","v","cljs.core/float?","cljs.core.conj","same$ish$Approximate$ish$dyn","x__4509__auto__","m__4510__auto__","same.ish/ish","goog/typeOf","m__4508__auto__","cljs.core/missing-protocol","same.ish/Approximate","this","that","goog.object/set","cljs.core._EQ_","same.platform/is-array?","cljs.core/count","cljs.core/every?","cljs.core/identity","cljs.core.map","cljs.core/sequential?","cljs.core.partial","cljs.core/apply","cljs.core/vector","cljs.core/map?","and__4210__auto__","vec__36885","vec__36888","this-floats","this-rest","cljs.core/keys","that-floats","that-rest","p1__36880#","cljs.core.get","p1__36881#","p2__36882#","cljs.core.sort","cljs.core/set?","vec__36893","vec__36896"],"sourcesContent":[";; Copyright (c) Microsoft Corporation. All rights reserved.\n;; Licensed under the MIT License.\n(ns same.ish\n  \"Comparing different types for same-ish-ness.\"\n  (:require [same.compare :refer [compare-ulp]]\n            [same.platform :as p]))\n\n(def default-comparator\n  \"The default comparator. Stored in a separate var to make it easier to reset after\n  modifying with [[set-comparator!]]\"\n  (compare-ulp 100.0 2))\n\n(def ^:dynamic *comparator*\n  \"The function for comparing individual floats/doubles.\n  Can be overridden using [[with-comparator]] or [[set-comparator!]].\"\n  default-comparator)\n\n;; Only public so that it can be called from same.diff\n(defn ^:no-doc split-floats\n  \"Split a collection into a vector of floating point values (of type Float or Double),\n  and a set of all other values.\"\n  [coll]\n  (reduce (fn [[floats rest] v]\n            (if (float? v)\n              [(conj floats v) rest]\n              [floats (conj rest v)]))\n          [[] #{}]\n          coll))\n\n(defprotocol Approximate\n  \"Protocol for approximately comparing any types (using [[*comparator*]] for floating point parts).\"\n  (ish [this that]\n    \"Return true if the two arguments are approximately equal.\"))\n\n#?(:clj\n   (extend-protocol Approximate\n     nil\n     (ish [_ that]\n       (nil? that))\n\n     Double\n     (ish [this that]\n       (and (number? that)\n            (*comparator* this that)))\n\n     Float\n     (ish [this that]\n       (and (number? that)\n            (*comparator* this that)))\n\n     Number\n     (ish [this that]\n       (cond (float? that)  (*comparator* (double this) that)\n             (number? that) (== ^Number this ^Number that)\n             :else          (= this that)))\n\n     clojure.lang.Sequential\n     (ish [this that]\n       (or (= this that)\n           (and (sequential? that)\n                (= (count this) (count that))\n                (every? (partial apply ish)\n                        (map vector this that)))))\n\n     java.util.Set\n     (ish [this that]\n       (or (= this that)\n           (and (instance? #?(:clj java.util.Set :cljs ISet) that)\n                (= (count this) (count that))\n                (let [[this-floats this-rest] (split-floats this)\n                      [that-floats that-rest] (split-floats that)]\n                  (and (= this-rest that-rest)\n                       (ish (sort this-floats) (sort that-floats)))))))\n\n     java.util.Map\n     (ish [this that]\n       (or (= this that)\n           (and (instance? #?(:clj java.util.Map :cljs IMap) that)\n                (= (count this) (count that))\n                (let [[this-floats this-rest] (split-floats (keys this))\n                      [that-floats that-rest] (split-floats (keys that))]\n                  (and (= this-rest that-rest)\n                       (every? #(ish (get this %) (get that %)) this-rest)\n                       (every? identity\n                               (map #(and (ish %1 %2)\n                                          (ish (get this %1) (get that %2)))\n                                    (sort this-floats)\n                                    (sort that-floats))))))))\n\n     Object\n     (ish [this that]\n       (if (and that (p/is-array? this) (p/is-array? that))\n         (and (= (count this) (count that))\n              (every? identity\n                      (map ish this that)))\n         (= this that))))\n\n   :cljs\n   (extend-protocol Approximate\n     nil\n     (ish [this that]\n       (nil? that))\n\n     number\n     (ish [this that]\n       (if (number? that)\n         (*comparator* this that)\n         (= this that)))\n\n     boolean\n     (ish [this that]\n       (= this that))\n\n     array\n     (ish [this that]\n       (and (p/is-array? that)\n            (= (count this) (count that))\n            (every? identity\n                    (map ish this that))))\n\n     string\n     (ish [this that]\n       (= this that))\n\n     object\n     (ish [this that]\n       (cond\n         (= this that)\n         true\n\n         (and (sequential? this) (sequential? that))\n         (and (= (count this) (count that))\n              (every? (partial apply ish)\n                      (map vector this that)))\n\n         (and (map? this) (map? that))\n         (and (= (count this) (count that))\n              (let [[this-floats this-rest] (split-floats (keys this))\n                    [that-floats that-rest] (split-floats (keys that))]\n                (and (= this-rest that-rest)\n                     (every? #(ish (get this %) (get that %)) this-rest)\n                     (every? identity\n                             (map #(and (ish %1 %2)\n                                        (ish (get this %1) (get that %2)))\n                                  (sort this-floats)\n                                  (sort that-floats))))))\n\n         (and (set? this) (set? that))\n         (and (= (count this) (count that))\n              (let [[this-floats this-rest] (split-floats this)\n                    [that-floats that-rest] (split-floats that)]\n                (and (= this-rest that-rest)\n                     (ish (sort this-floats) (sort that-floats)))))\n\n         :else\n         false))))\n"]}