{"version":3,"sources":["same/compare.cljc"],"mappings":";AAMA,gCAAA,hCAAOA,wEACJC,EAAEC;AADL,AAEE,QAAYD,KAAW,AAACE,kBAAcD;;AAOxC;;;yBAAA,zBAAME,0DAEHH,EAAEC;AAFL,AAMW,OAACF,8BAAiBC,EAAEC;;AAE/B,kCAAA,lCAAOG,4EACJC,GAAGC,GAAGC,QAAQC;AADjB,AAEE,IAAMH,SAAWA;IACXC,SAAWA;AADjB,AAEE,GAEE,CAAI,AAACG,SAAS,CAAGJ,SAAGC,YAAaC;AAFnC;;AAAA,GAME,AAACG,gDAAK,AAACC,mBAAON,QAAI,AAACM,mBAAOL;AAN5B;;AAAA,GAUE,AAACI,gDAAK,AAACE,iCAAeP,QAAI,AAACO,iCAAeN;AAV5C;;AAAA,AAeE,QAAI,AAAOO,8BAAkBR,OAAGC,WAC5B,AAACQ,gBAAKN;;;;;;AAsBhB;;;2BAAA,3BAAMO,8DAEHd,MAAMO;AAFT,AAWK,IAAMD,UAAQ,AAACL,kBAAMD;AAArB,AACE,kBAAKI,GAAGC;AAAR,AACE,OAACF,gCAAmBC,GAAGC,GAAGC,QAAQC","names":["same.compare/near-zero-double","f","scale","same.platform/ulp","same.compare/near-zero","same.compare/compare-ulp-double","f1","f2","max-abs","max-ulp","Math/abs","cljs.core.not_EQ_","same.platform/sign","same.platform/is-infinite?","same.platform/bit-diff-double","cljs.core/long","same.compare/compare-ulp"],"sourcesContent":[";; Copyright (c) Microsoft Corporation. All rights reserved.\n;; Licensed under the MIT License.\n(ns same.compare\n  \"Default comparator functions.\"\n  (:require [same.platform :as p]))\n\n(defn- near-zero-double\n  [f scale]\n  (<= (double f) (double (p/ulp (double scale)))))\n\n#?(:clj\n   (defn- near-zero-float\n     [f scale]\n     (<= (float f) (float (p/ulp (float scale))))))\n\n(defn near-zero\n  \"Test if a number is near zero.\"\n  [f scale]\n  #?(:clj (if (instance? Float f)\n            (near-zero-float f scale)\n            (near-zero-double f scale))\n     :cljs (near-zero-double f scale)))\n\n(defn- compare-ulp-double\n  [f1 f2 max-abs max-ulp]\n  (let [f1 (double f1)\n        f2 (double f2)]\n    (cond\n      ;; First check absolute difference (in case we are near zero).\n      (<= (Math/abs (- f1 f2)) (double max-abs))\n      true\n\n      ;; Either they have different signs, or at least one is NaN.\n      (not= (p/sign f1) (p/sign f2))\n      false\n\n      ;; Only one is infinite, it cannot be close to any finite value.\n      (not= (p/is-infinite? f1) (p/is-infinite? f2))\n      false\n\n      ;; Otherwise check relative difference in ULPs.\n      :else\n      (<= ^long (p/bit-diff-double f1 f2)\n          (long max-ulp)))))\n\n#?(:clj\n   (defn- compare-ulp-float\n     [f1 f2 max-abs max-ulp]\n     (let [f1 (float f1)\n           f2 (float f2)]\n       ;; Same logic as compare-ulp-double, but for (single-precision) floats.\n       (cond\n         (<= (Math/abs (- f1 f2)) (double max-abs))\n         true\n\n         (not= (p/sign f1) (p/sign f2))\n         false\n\n         (not= (p/is-infinite? f1) (p/is-infinite? f2))\n         false\n\n         :else\n         (<= ^long (p/bit-diff-float f1 f2)\n             (long max-ulp))))))\n\n(defn compare-ulp\n  \"Create a comparator function that compares numbers by ULPs.\"\n  [scale max-ulp]\n  #?(:clj\n     (let [max-abs-double (p/ulp (double scale))\n           max-abs-float  (p/ulp (float scale))]\n       (fn [f1 f2]\n         (if (instance? Float f1)\n           (compare-ulp-float  f1 f2 max-abs-float  max-ulp)\n           (compare-ulp-double f1 f2 max-abs-double max-ulp))))\n     :cljs\n     (let [max-abs (p/ulp scale)]\n       (fn [f1 f2]\n         (compare-ulp-double f1 f2 max-abs max-ulp)))))\n"]}